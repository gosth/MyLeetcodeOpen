# 回溯算法Backtracking

## 定义
回溯算法是一种搜索算法，用于找出在问题的所有可能解中满足特定条件的解，或者找到满足条件的一个解。这种算法会在可能的解空间中递归搜索，并依赖于深度优先搜索（DFS）和剪枝策略，如果在探索路径中遇到不满足条件的解，就返回上一步或几步（回溯），并尝试其他可能路径。

## 回溯法解决的问题类型
+ 组合问题：N个数里面按一定规则找出k个数的集合
+ 切割问题：一个字符串按一定规则有几种切割方式
+ 子集问题：一个N个数的集合里有多少符合条件的子集
+ 排列问题：N个数按一定规则全排列，有几种排列方式
+ 棋盘问题：N皇后，解数独等等

## 回溯算法框架
+ 路径：也就是已经做出的选择。
+ 选择列表：也就是你当前可以做的选择。
+ 结束条件：也就是到达决策树底层，无法再做选择的条件。
```python
result = []
def backtrack(路径, 选择列表, 其他参数):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表(本层集合中元素,树中节点孩子的数量就是集合的大小):
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
![Alt text](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

## 判断是否可用回溯算法
+ 求的是所有的方案，而不是方案数。 由于求的是所有方案，不可能有什么特别的优化，我们只能进行枚举。这时候可能的解法有动态规划、记忆化搜索、DFS+回溯算法（这种情况，务必优先考虑回溯）。

+ 通常数据范围不会太大，只有几十。 如果是动态规划或是记忆化搜索的题的话，由于它们的特点在于低重复/不重复枚举，所以一般数据范围可以出到1E5到1E7，而DFS+回溯的话，通常会限制在 30 以内。

## 回溯的思考方法-回溯三问
回溯三问是回溯问题和动态规划问题的思考模板。
1.  当前操作是什么？
2.  子问题是什么？
3.  下一个子问题是什么？

## 回溯算法的两套模板
回溯算法有两套模板，分别是“从输入角度思考”，“从答案角度思考”。遇到问题，可以用两种方式思考，看看哪种实现更简单。通过例题，提供两种模板的思考方式（回溯三问）。78题《子集》为例，提供无重复元素数组，构造其所有子集。

### 从”输入角度思考“：站在”输入”角度，每个输入元素可以“选”或“不选”。
#### 回溯三问
1. 当前操作？枚举第i个数选/不选
2. 子问题？从下标>=i的数字中构造子集
3. 下一个子问题？从下标>=i + 1的数字中构造子集

#### 代码模板
```cpp
void dfs(当前位置, 路径(当前结果), 结果集) {
    if (当前位置 == 结束位置) {
        结果集.add(路径);
        return;
    }
        
    选择当前位置;    
    dfs(下一位置, 路径(当前结果), 结果集);
    撤销选择当前位置;
    dfs(下一位置, 路径(当前结果), 结果集);
}
```
对应到这类模板的题目有：40. 组合总和 II

### 从”答案角度思考“：站在“答案”角度。枚举当前选择列表，每次都”选“。

#### 回溯三问
1. 当前操作？枚举枚举一个下标j>=i的数字，加入path
2. 子问题？从下标>=i的数字中构造子集
3. 下一个子问题？从下标>=j + 1的数字中构造子集

#### 代码模板
```cpp
void dfs(选择列表, 路径(当前结果), 结果集) {
    if (满足结束条件) {
        结果集.add(路径);
        return;
    }
        
    for (选择 in 选择列表) {
        做选择;
        dfs(路径’, 选择列表, 结果集);
        撤销选择;
    }
}
```
对应到这类模板的题目有：17. 电话号码的数字组合、39. 组合总和 

## 回溯总结
![Alt text](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png)
![Alt text](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)



